package cpu_test

import (
	"testing"
	"github.com/gorkaio/gboy/pkg/cpu"
)

func TestInc(t *testing.T) {
	for _, test := range testCasesForIncrement() {
		testInstruction(t, test)
	}
}

func testCasesForIncrement() []testCase {
	return []testCase{
		{
			description: "'INC BC' increments BC register and clears negative flag",
			instruction: []byte{0x03, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0x1234,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0x1235,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC BC' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x03, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0xFFFF,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC BC' does not clear carry flag when it was previously set",
			instruction: []byte{0x03, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x1234,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x1235,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC BC' sets half-carry flag when increment carries in bits 7-8",
			instruction: []byte{0x03, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0xF0FF,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0xF100,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC DE' increments DE register and clears negative flag",
			instruction: []byte{0x13, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0x1234,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x1235,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC DE' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x13, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0xFFFF,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC DE' does not clear carry flag when it was previously set",
			instruction: []byte{0x13, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x1234,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x1235,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC DE' sets half-carry flag when increment carries in bits 7-8",
			instruction: []byte{0x13, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0xF0FF,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0xF100,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC HL' increments HL register and clears negative flag",
			instruction: []byte{0x23, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0x1234,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x1235,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC HL' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x23, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0xFFFF,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC HL' does not clear carry flag when it was previously set",
			instruction: []byte{0x23, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x1234,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x1235,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC HL' sets half-carry flag when increment carries in bits 7-8",
			instruction: []byte{0x23, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0xF0FF,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0,
				HL: 0xF100,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC SP' increments SP register and clears negative flag",
			instruction: []byte{0x33, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0x1234,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0x1235,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC SP' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x33, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0xFFFF,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC SP' does not clear carry flag when it was previously set",
			instruction: []byte{0x33, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0x1234,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0x1235,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC SP' sets half-carry flag when increment carries in bits 7-8",
			instruction: []byte{0x33, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0xF0FF,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0xF100,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 8,
		},
		{
			description: "'INC A' increments A register and clears negative flag",
			instruction: []byte{0x3C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0x0100,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC A' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x3C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0xFF00,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC A' does not clear carry flag when it was previously set",
			instruction: []byte{0x3C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0x1200 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0x1300 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC A' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x3C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0x0F00,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0x1000 | FlagH,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC B' increments B register and clears negative flag",
			instruction: []byte{0x04, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0  | FlagN,
				BC: 0x1234,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0x1334,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC B' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x04, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0xFF03,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0x0003,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC B' does not clear carry flag when it was previously set",
			instruction: []byte{0x04, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x1200,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x1300,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC B' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x04, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0x0F00,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0x1000,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC C' increments C register and clears negative flag",
			instruction: []byte{0x0C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0x1234,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0x1235,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC C' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x0C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0x12FF,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0x1200,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC C' does not clear carry flag when it was previously set",
			instruction: []byte{0x0C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x12,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0x13,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC C' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x0C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0x0F,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0x10,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC D' increments D register and clears negative flag",
			instruction: []byte{0x14, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x0100,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC D' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x14, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0xFF03,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0x0003,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC D' does not clear carry flag when it was previously set",
			instruction: []byte{0x14, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x1200,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x1300,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC D' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x14, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x0F00,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0x1000,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC E' increments E register and clears negative flag",
			instruction: []byte{0x1C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0x1234,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x1235,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC E' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x1C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x12FF,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0x1200,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC E' does not clear carry flag when it was previously set",
			instruction: []byte{0x1C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x12,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0x13,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC E' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x1C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0x0F,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0x10,
				HL: 0,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC H' increments H register and clears negative flag",
			instruction: []byte{0x24, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x0100,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC H' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x24, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0xFF03,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0x0003,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC H' does not clear carry flag when it was previously set",
			instruction: []byte{0x24, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x1200,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x1300,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC H' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x24, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x0F00,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0,
				HL: 0x1000,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC L' increments L register and clears negative flag",
			instruction: []byte{0x2C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagN,
				BC: 0,
				DE: 0,
				HL: 0x1234,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x1235,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC L' sets zero flag when result is zero without affecting carry flag",
			instruction: []byte{0x2C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x12FF,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagZ | FlagH,
				BC: 0,
				DE: 0,
				HL: 0x1200,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC L' does not clear carry flag when it was previously set",
			instruction: []byte{0x2C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x12,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagC,
				BC: 0,
				DE: 0,
				HL: 0x13,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
		{
			description: "'INC L' sets half-carry flag when increment carries in bits 3-4",
			instruction: []byte{0x2C, 0x00, 0x00, 0x00},
			initialState: cpu.State{
				AF: 0,
				BC: 0,
				DE: 0,
				HL: 0x0F,
				SP: 0,
				PC: 0x100,
				IME: false,
			},
			expectedState: cpu.State{
				AF: 0 | FlagH,
				BC: 0,
				DE: 0,
				HL: 0x10,
				SP: 0,
				PC: 0x101,
				IME: false,
			},
			expectedReads: []memoryAccess{},
			expectedWrites: []memoryAccess{},
			expectedCycles: 4,
		},
	}
}